{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Project Overview","text":"<p>This documentation covers a few core systems in Silvergrove Studio's Project Arsenic, which can be found in this GitHub repo. Project Arsenic is an in-production commercial game that has a vertical slice scheduled to be done sometime before the end of the year (2025). The game is a DnD-style Sci-Fi RPG with puzzle elements and a focus on combat. This documentation and the code/blueprints showcased within was written exclusively by me (Michael \"pterafier\" Durkin) with the  exception of the <code>UPylonManager</code>, which was written by another Silvergrove Studio programmer and will not be referenced in this documentation.</p> <p>This project uses GAS and Common UI, two plugins whose setup will not be documented here, as there is plenty of documentation on how to set those up. I will discuss any systems that relate to or extend GAS and Common UI, however, and there are plenty of those. There are random notes about GAS in the code itself that were used for learning, transferred between projects and never  deleted, or for assisting other team members.</p> <p>The point of this documentation is to showcase my understanding of the various systems I've programmed and to show recruiters and hiring managers that I have some experience writing documentation  in a convenient and polished location that doesn't require invitations or authorization. If you're one of the aforementioned individuals this work is catered to, hello!</p> <p>If you've somehow landed here without knowing anything about me, check out my portfolio or my itch page to play my games or  see more of my work.</p>"},{"location":"Doors/","title":"Doors","text":""},{"location":"Doors/#overview","title":"Overview","text":"<p>Doors inherit from <code>AArsenicInteractActorBase</code> and have their own base class <code>AArsenicDoorBase</code>. In order for the doors to manage their state as <code>World Partition</code> loads and unloads them, as well as integrating with the save system, doors must have a <code>UniqueDoorName</code>. For organizational purposes I strongly recommend using the following format: \u201c<code>CardinalDirection RoomName DoorName DoorNumber</code>\u201d. For example, a door in the atrium might have the name \u201c<code>West Atrium HiddenDoor 0</code>\u201d. You are not required to follow this naming convention, but it will be very hard to have duplicate door names with this system. Keep in mind that if door names are duplicated their state will not be saved/loaded properly. </p> <p>Doors get split into child classes to make things easier for designers, however this means that some doors have different features than others. Here are some features and functions that you\u2019ll find in the various door classes:</p> <ul> <li><code>bool StartOpened;</code></li> <li><code>bool CloseDoorAutomatically;</code></li> <li><code>TrySlamDoor();</code> - called when the door gets locked while the door is open</li> <li><code>float SlamSpeedMultiplier;</code> - Multiplied by <code>DefaultDoorSpeed</code> when the door gets slammed</li> <li><code>LockDoor();</code></li> <li><code>UnlockDoor();</code></li> </ul> <p>There are also several blueprint implementable events that can be called by designers in blueprint to spawn sounds and handle other behaviors:</p> <ul> <li><code>OnDoorLocked();</code></li> <li><code>OnDoorUnlocked();</code></li> <li><code>OnDoorStartOpen();</code></li> <li><code>OnDoorFinishOpen();</code></li> <li><code>OnDoorStartClose();</code></li> <li><code>OnDoorStartSlam();</code></li> <li><code>OnDoorFinishClose();</code></li> <li><code>OnActionTextChanged();</code></li> <li><code>OnDoorStateLoaded();</code></li> </ul> <p>For optimization purposes, doors do not use collision spheres to detect when the player is nearby. Instead, every second (or half-second for sliding doors) the distance between the door and player is calculated and automatic doors will open and close when certain thresholds are met. This means that thresholds need to be slightly higher than expected due to the delay in distance calculations.</p> <p>There are some helpful debug tools set up on the player character to lock and unlock doors for testing, but I can\u2019t promise that functionality will stick around forever:</p> <p></p>"},{"location":"Doors/#aarsenicdoubledoor","title":"AArsenicDoubleDoor","text":"<p>Because of the need for a second mesh and second open point vector, this child class was created. They should be able to just be dragged into the world and work as expected. There are many configurable variables you can set in the details panel if you want different behavior.</p>"},{"location":"Doors/#bp_singleslidingdoor","title":"BP_SingleSlidingDoor","text":"<p>These are configurable to be vertical sliding doors and horizontal sliding doors. The <code>OpenPoint1</code> vector just needs to be manipulated to achieve the desired result. To anyone reading this, you\u2019re welcome to create another <code>AArsenicDoorBase</code> to separate horizontal and vertical sliding doors. These work exactly the same as double sliding doors, except for the need to manually set <code>OpenPoint1</code>.</p>"},{"location":"Doors/#hinged-doors","title":"Hinged Doors","text":"<p>Hinged doors were formerly split up into <code>BP_SimpleHingedDoor</code> and <code>BP_StatHingedDoor</code> but have since been combined into a single class. If you need the functionality of a <code>StatHingedDoor</code>, simply tick the <code>RequiresStatCheck</code> box, configure the door to your liking, then fill out the <code>AC_StatInteraction</code> component to ensure the UI shows everything it needs to. When the stat interaction is completed, the door will stop using the <code>AC_StatInteraction</code> component and start using the <code>AC_SimpleInteraction</code> component and behave like a standard hinged door.</p>"},{"location":"Doors/#managing-doors-with-world-partition","title":"Managing Doors With World Partition","text":"<p>The save game subsystem (currently <code>UArsenicSaveGameSubsystem</code>) contains <code>TMap&lt;FName, FDoorSave&gt; CollectedDoorData;</code>. This gets updated every time the door state changes. Each individual door handles its own update to this map, allowing a running list of doors to be collected and stored in this variable as the player runs around the world. The doors then reference this list every time they\u2019re loaded to see if they have an entry that contains their <code>UniqueDoorName</code>. If one exists, they set their state based on that data. If not, they run <code>InitializeFirstTimeDoorState();</code> and register themselves with the save game subsystem. </p>"},{"location":"GAS/","title":"GAS &amp; Attributes","text":"<p>There isn\u2019t a lot to document here other than a few details that will help with working with attributes and the <code>UArsenicAbilitySystemComponent</code>. Ability System blueprints are in the following file path:</p> <p></p>"},{"location":"GAS/#attributes","title":"Attributes","text":"<p>We initialize attributes via gameplay effects, but because we have to think about saving and loading attribute data, we need a convenient place to store and retrieve data, and a way to dynamically set modifier magnitude values within gameplay effects. I made a struct in the <code>AArsenicCharacterBase</code> that sets the initial values for the attributes. In the editor, there\u2019s a gameplay effect called <code>GE_InitializeAttributes</code> that defines which attributes to initialize. Instead of setting the <code>ModifierMagnitude</code> values in that effect, we set the <code>ModifierMagnitude type</code> to <code>SetByCaller</code> which allows us to set the attribute value in code, which is done on the <code>AArsenicPlayerState</code> class in the <code>InitializeAttributes</code> function. There\u2019s some additional logic that determines whether or not to initialize attributes from save data or to initialize based on the default values in the struct on the base character class.</p> <p>Overall, the <code>AArsenicPlayerState</code> handles the vast majority of attribute details for the player character, including binding to <code>OnAttributeChanged</code> delegates, which will be important to know how to do for other objects and classes. This approach is how we can manipulate the player\u2019s walk speed via gameplay effects:ww</p> <pre><code>void AArsenicPlayerState::BindAttributeDelegates()\n{\n    check(ArsenicAbilitySystemComponent)\n\n    ArsenicAbilitySystemComponent-&gt;GetGameplayAttributeValueChangeDelegate(UArsenicAttributeSet::GetWalkSpeedAttribute()).AddUObject(this, &amp;ThisClass::OnWalkSpeedChanged_Callback);\n    ArsenicAbilitySystemComponent-&gt;GetGameplayAttributeValueChangeDelegate(UArsenicAttributeSet::GetLookSpeedAttribute()).AddUObject(this, &amp;ThisClass::OnLookSpeedChanged_Callback);\n}\n</code></pre> <p>Lastly, there\u2019s a throwaway test effect that can be used to test how effects work without having to think about organization or structure. A design space, so to speak. Use it or don\u2019t, it won\u2019t end up in the final game.</p> <p></p>"},{"location":"GAS/#general-gas","title":"General GAS","text":"<p>The <code>AArsenicPlayerCharacter</code> class has a startup abilities array that defines which abilities to grant the player when the game starts. This is the easiest way to grant player abilities at startup and showcases how to grant abilities to the player at other times.</p> <p>The <code>AArsenicCharacterBase</code> class has some notes on how GAS works that I wrote when I was taking the GAS course. They might help you in the future!</p> <p>The <code>UArsenicAbilitySystemComponent</code> has a custom function that applies a gameplay effect to a target actor who also implements an ability system component. It\u2019s called <code>ApplyEffectToTarget</code> and is blueprint callable:</p> <p></p>"},{"location":"Interaction/","title":"Interaction","text":""},{"location":"Interaction/#aarsenicinteractactorbase","title":"AArsenicInteractActorBase","text":"<p>This is the class all interactable objects should inherit from as it has many useful functions, events, and variables that help inform designers and programmers of the current state of the object, along with handling mesh highlights. It comes with a few blueprint implementable events:</p> <ul> <li><code>BeginHighlight();</code> - called when the actor gets highlighted</li> <li><code>EndHighlight();</code> - called when the actor gets unhighlighted</li> <li><code>StopLookingAt();</code> - called when the player stops looking at the actor</li> </ul> <p>Additionally, it comes with a few helpful blueprint-callable functions and variables:</p> <ul> <li><code>SetAllowInteraction(bool bAllowInteraction, bool bUseHighlight);</code></li> <li><code>HighlightMesh();</code></li> <li><code>UnHighlightMesh();</code></li> <li><code>bool isInteractable;</code></li> <li><code>bool isHighlighted;</code></li> </ul> <p>It is very important to note that the <code>SceneComponent</code> and <code>StaticMesh</code> are NOT initialized in the base class and must be set in child classes if they\u2019re to be used:</p> <p></p> <p>Initialize these in child classes by using <code>CreateDefaultSubobject&lt;UCLASS&gt;(\"COMPONENT_NAME);</code></p>"},{"location":"Interaction/#highlighting-meshes","title":"Highlighting Meshes","text":"<p>Highlighting works by using a <code>PostProcessVolume</code> with <code>InfiniteExtent</code> set to <code>true</code> and the material set to <code>PP_Highlight</code>:</p> <p></p> <p>The highlights currently support multiple static mesh components being highlighted together, but requires that each mesh be added to the <code>HighlightMeshes</code> array in the construction script:</p> <p></p> <p>Make sure the original static mesh is added too!</p> <p>If the object only requires that 1 mesh be highlighted, no additional work is required to make the mesh highlight, as long as the mesh that comes with the actor has been initialized in the C++ constructor ( <code>ACLASSNAME();</code> ) and the mesh is set in blueprint.</p>"},{"location":"Interaction/#simple-interact-component","title":"Simple Interact Component","text":"<p>This actor component (created entirely in blueprint) replaces what used to be <code>SimpleInteractActors</code> to allow for much more versatility at the cost of a little extra work, but fortunately all of that is handled in blueprint and is pretty straightforward.</p> <p>This component comes with several functions that can be utilized by owning actors to create and remove the appropriate widget when looked at. Here\u2019s a list of functions:</p> <ul> <li><code>CreateSimpleWidget(FText ActionText);</code> - creates the interact widget </li> <li><code>RemoveWidget();</code> - tries to remove the interact widget</li> <li><code>SetActionText(FText ActionText);</code></li> <li><code>SimpleLookAt(bool AllowInteraction, FText ActionText);</code> - Placed in owner LookAt functions to create references and automatically generate the widget</li> <li><code>ConfigureWidget(FText ActionText, FInputAction InputAction);</code> - useful for updating the interact widget while it's still on the screen</li> </ul> <p></p> <p>The simplest implementation of the component on an interact actor. These function calls are required but can be manipulated to achieve what you want</p> <p>This component was designed to be implemented in classes that inherit from <code>AArsenicInteractActorBase</code>. An excellent example of this component in use is on <code>BP_HingedDoor</code>:</p> <p></p>"},{"location":"Interaction/#stat-interact-component","title":"Stat Interact Component","text":"<p>Shares almost all the same functions as the <code>Simple Interact Component</code> with some extra inputs to configure the stat interact widget, and a brand new pure function <code>bool HasEnoughAttributeValue(FGameplayAttribute AttributeToCheck);</code></p> <p>It has nearly identical setup as the <code>Simple Interact Component</code> as well:</p> <p></p> <p>The component can be configured on a per-instance basis by selecting it in the details panel of the interactable object:</p> <p></p> <p>You can find an example of this in use on <code>BP_HingedDoor</code> (See Simple Interact Component for file path)</p>"},{"location":"Menus%20%26%20Widgets/","title":"Menus &amp; Widgets","text":"<p>This document will cover the most important things to know about how the widget system is set up, and how you can best utilize the tools and functions within.</p>"},{"location":"Menus%20%26%20Widgets/#overview","title":"Overview","text":"<p>There exists a class called <code>UMainWidget</code>. This widget is on screen permanently and is the base from which all other widgets are added and shown. As such,  <code>AArsenicPlayerController</code> has a reference to this widget so we can access its functions at any time from anywhere. The various functions that live on this  widget help with adding and removing widgets to/from the screen, setting input modes, and handling the mouse cursor. Most of that is handled automatically  when you call <code>PushWidgetToTargetStack</code>. The main widget has 4 stacks that you can push menus to: </p> <ul> <li><code>HUD_Stack</code> (which is pretty much used only once to add the  HUD), </li> <li><code>InteractableHUD_Stack</code> (for drag and drop inventories and such), </li> <li><code>Menu_Stack</code> (for menus like a pause menu or settings menu), and the </li> <li><code>Popup_Stack</code> (for context widgets). </li> </ul> <p>For more details, go to <code>UI-&gt;Widgets-&gt;MainWidget.h</code></p> <p>The <code>Common UI</code> plugin has also been set up to detect which input device is being used, and <code>UCommonActionWidgets</code> set input icons automatically based on those  input types. Conveniently, I've created a <code>UBottomNavBarBase</code> class that can be added to any <code>UArsenicMenuBase</code> (important, it MUST be <code>UArsenicMenuBase</code>) that  contains a button that will handle closing the current widget. It works like you'd expect a back button to.</p> <p></p>"},{"location":"Menus%20%26%20Widgets/#input","title":"Input","text":"<p>When a menu is opened, we must call <code>SwitchToMenuInput()</code> on the <code>ArsenicPlayerController</code>. This removes the Gameplay Input Mapping Context which moves the character,  and replaces it with the Menu Input Mapping Context which helps with navigating menus. When <code>MainWidget</code> no longer has any widgets pushed, it broadcasts <code>OnStacksCleared</code> which the <code>PlayerController</code> responds to by calling <code>SwitchToGameplayInput()</code>. UI inputs are in <code>_GAME-&gt;UI-&gt;Input-&gt;InputActions</code>, and gameplay inputs are in  <code>_GAME-&gt;Blueprints-&gt;Player-&gt;Input-&gt;InputActions</code></p> <p>Widgets can't (and won't) behave as expected when using traditional Input Actions directly in the widget because of a bug in the engine version we're using. Instead, menus  have to respond to input by responding to delegates broadcast by the <code>ArsenicPlayerController</code>. For example, to tab left or tab right, the <code>ArsenicPlayerController</code> broadcasts  that one of those inputs has been pressed. Then, the <code>Settings</code> menu responds by changing the widget index. Callbacks are set up in blueprint so we can access various widget  components more easily, but the broadcasts themselves are handled in C++ by the <code>ArsenicPlayerController</code>. </p> <p></p> <p><code>Common UI</code> supports global back actions, and our menu system makes great use of them. If you're creating a menu that you'll want to close by simply pressing <code>B</code> on controller or <code>ESC</code>, inherit from <code>UArsenicMenuBase</code>. This automatically responds to back actions, but requires that <code>IsModal</code> and <code>IsBackHandler</code> are set to <code>true</code>. You can find these bools in the widget's  details panel. When you inherit from <code>UArsenicMenuBase</code>, you can also add a <code>UBottomNavBarBase</code> widget to add a clickable back button and navigation icons that change based on the current  input device. </p> <p></p>"},{"location":"Menus%20%26%20Widgets/#focus","title":"Focus","text":"<p><code>Focus</code> is used to allow controllers to navigate menus, and is also one of the strongest points of frustration in UMG. We will be dealing with this for the duration of the project, so make  sure you follow these steps to minimize frustration and maximize functionality. In the details panel of your widget blueprint:</p> <ul> <li>Set <code>IsFocusable</code> to <code>true</code>, and ensure the <code>DesiredFocusWidget</code> is set to <code>self</code> (or a button depending on your menu)</li> <li><code>Supports Activation Focus</code> should be <code>true</code>, and depending on your menu, <code>Auto Restore Focus</code> should be <code>true</code> as well but is not required.</li> <li>Ensure the <code>Input Config</code> is set to <code>Game and Menu</code> and that <code>Game Mouse Capture Mode</code> is set to <code>No Capture</code>.</li> <li>Lastly, in the widget blueprint's event graph, override the <code>GetDesiredFocusTarget</code> function and set the return value to either <code>Self</code> or a button in your widget hierarchy. Then <code>OnActivated</code>, call  <code>SetFocus</code> - the target is <code>GetDesiredFocusTarget</code>. You may have to add a small delay to account for widget transition animation time. This is displayed in <code>WB_PauseMenu</code> and <code>WB_SettingsMenu</code>, with  the settings menu having tabbed navigation and sub-widget input logic.</li> </ul> <p></p> <p></p>"},{"location":"Saving/","title":"Saving &amp; Loading","text":"<p>This documentation provides an overview of the save system, examples of how to save and load data with actual game objects, and checkpoint functionality in the Arsenic game project.</p>"},{"location":"Saving/#overview","title":"Overview","text":"<p>The save system utilizes structs to store large amounts of data per-object. Structs can be defined in the <code>.h</code> file of the object that requires saving \u2014 like in the player state:</p> <p><pre><code>USTRUCT(BlueprintType)\nstruct FPlayerSave : public FTableRowBase\n{\n    GENERATED_BODY()\n\npublic:\n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Settings\")\n    FTransform PlayerTransform;\n\n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Settings\")\n    FRotator PlayerControlRotation;\n\n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Settings\")\n    float PlayerHealth;\n\n    FPlayerSave() :\n        PlayerTransform(FTransform(FRotator::ZeroRotator, FVector::ZeroVector, FVector(1.0f))),\n        PlayerControlRotation(FRotator::ZeroRotator),\n        PlayerHealth(-1.f)\n    {}\n};\n</code></pre> Because of this approach, the <code>UArsenicSaveGameObject</code> will need to include a tremendous number of header files and variables of each object\u2019s save struct type.</p> <p>This only affects compile times, not runtime optimization.</p> <p>When creating your own savable object, make sure to add the struct as a variable in the save game object:</p> <pre><code>UCLASS()\nclass ARSENIC_API UArsenicSaveGameObject : public USaveGame\n{\n    GENERATED_BODY()\n\npublic:\n    UPROPERTY(VisibleAnywhere, BlueprintReadWrite, Category = \"Save\")\n    FAudioSave AudioData;\n\n    UPROPERTY(VisibleAnywhere, BlueprintReadWrite, Category = \"Save\")\n    FGraphicsSave GraphicsData;\n\n    UPROPERTY(VisibleAnywhere, BlueprintReadWrite, Category = \"Save\")\n    FPlayerSave PlayerData;\n\n    UPROPERTY(VisibleAnywhere, BlueprintReadWrite, Category = \"Save\")\n    FCharacterAttributes PlayerAttributes;\n\n    UPROPERTY(VisibleAnywhere, BlueprintReadWrite, Category = \"Save\")\n    FControlsSave ControlsData;\n\n    UPROPERTY(VisibleAnywhere, BlueprintReadWrite, Category = \"Save\")\n    FPylonStateSave PylonStateData;\n\n    UPROPERTY(VisibleAnywhere, BlueprintReadWrite, Category = \"Save\")\n    TMap&lt;FName, FDoorSave&gt; DoorData;\n};\n</code></pre> <p>The <code>UArsenicSaveGameSubsystem</code> and <code>IArsenicSaveGameInterface</code> will need functions to set the struct on the save game object \u2014 essentially just updating it with new data. This is discussed further below.</p>"},{"location":"Saving/#notes-for-non-programmers","title":"Notes for Non-Programmers","text":"<ul> <li>It is entirely possible that save data will create strange or buggy behavior. You can safely delete save data by locating the save file in the project directory:</li> </ul> <ul> <li>BP_PlayerState has a checkbox that stops the player character\u2019s saved data from being loaded when the game starts. By default it\u2019s set to true but you may want to avoid loading it for one reason or another:</li> </ul>"},{"location":"Saving/#classes","title":"Classes","text":""},{"location":"Saving/#uarsenicsavegamesubsystem","title":"UArsenicSaveGameSubsystem","text":"<p>Manages game-wide save data, general settings, and persistence. It is responsible for loading and saving game data asynchronously and tracking the state of objects as <code>World Partition</code> loads and unloads them.  This is the central hub that controls the physical saving and loading of data in the game.  You can access the subsystem from any class by using its static <code>Get</code> function and passing in a world context object:</p> <pre><code>UArsenicSaveGameSubsystem* SaveSubsystem = UArsenicSaveGameSubsystem::Get(this);\n</code></pre>"},{"location":"Saving/#iarsenicsavegameinterface","title":"IArsenicSaveGameInterface","text":"<p>An organizational tool that stores the functions the game instance uses to save and load the various data in the game. This also ensures programmers don\u2019t have to constantly cast to the save game subsystem and instead  can call interface functions by using <code>Execute_FUNCTION_NAME</code> as shown below: </p> <pre><code>void AArsenicCheckpoint::OnTriggerBoxBeginOverlap(UPrimitiveComponent* OverlappedComponent, \nAActor* OtherActor, \nUPrimitiveComponent* OtherComp, \nint32 OtherBodyIndex, \nbool bFromSweep, \nconst FHitResult&amp; SweepResult)\n{\n    if (OtherActor != UGameplayStatics::GetPlayerCharacter(this, 0)) return;\n\n    UArsenicSaveGameSubsystem* SaveSubsystem = UArsenicSaveGameSubsystem::Get(this);\n    if (!SaveSubsystem) return;\n    if (!SaveSubsystem-&gt;CanSave) return; // helps prevent an unintentional save when the player transform is updated at begin play\n\n    IArsenicSaveGameInterface* SaveGameInterface = SaveSubsystem;\n    FetchSaveData();\n    SaveGameInterface-&gt;Execute_SetPlayerSaveData(SaveSubsystem, PlayerSaveData);\n    SaveGameInterface-&gt;Execute_SetPlayerAttributes(SaveSubsystem, PlayerAttributes);\n    SaveGameInterface-&gt;Execute_SetPylonSaveData(SaveSubsystem, PylonSaveData);\n    SaveGameInterface-&gt;Execute_SetDoorSaveData(SaveSubsystem, SaveSubsystem-&gt;CollectedDoorData);\n    SaveGameInterface-&gt;Execute_SaveGameData(SaveSubsystem);\n}\n</code></pre> <p>This interface will need to be updated every time a new savable object is created, and its function will need to be implemented in the <code>UArsenicSaveGameSubsystem</code></p>"},{"location":"Saving/#uarsenicsavegameobject","title":"UArsenicSaveGameObject","text":"<p>This is the container that all save data is stored in. Accessing this object will allow us to retrieve saved data, however it doesn\u2019t have any functions of its own as of the time this documentation is written.  Retrieving variables from this object can be done by accessing the <code>UArsenicSaveGameSubsystem</code> and calling <code>Execute_GetSaveGameData(SaveSubsystem)</code> to retrieve the <code>UArsenicSaveGameObject</code>, then accessing  variables from that. An example is shown in the <code>AArsenicPlayerState</code>:</p> <pre><code>void AArsenicPlayerState::SetPlayerStateFromSaveData()\n{\n    UArsenicSaveGameSubsystem* SaveSubsystem = UArsenicSaveGameSubsystem::Get(this);\n    UArsenicSaveGameObject* SaveGameObject = IArsenicSaveGameInterface::Execute_GetSaveGameData(SaveSubsystem);\n\n    if (SaveSubsystem-&gt;DoesSaveExist)\n    {\n        if (SaveSubsystem-&gt;SaveObjectInitialized)\n        {\n            FPlayerSave PlayerData = SaveGameObject-&gt;PlayerData;\n            ArsenicPlayerCharacter-&gt;SetActorTransform(PlayerData.PlayerTransform);\n            ArsenicPlayerCharacter-&gt;ArsenicPlayerController-&gt;SetControlRotation(PlayerData.PlayerControlRotation);\n\n            InitializeAttributes(SaveGameObject-&gt;PlayerAttributes);\n        }\n        else\n        {\n            if (BoundToDelegate) return;\n            SaveSubsystem-&gt;OnSaveGameObjectLoaded.AddDynamic(this, &amp;ThisClass::OnSaveGameObjectLoaded_Callback);\n            BoundToDelegate = true;\n        }\n    }\n    else\n    {\n        FCharacterAttributes NewPlayerAttributes;\n        InitializeAttributes(NewPlayerAttributes);\n    }\n}\n</code></pre>"},{"location":"Saving/#aarseniccheckpoint","title":"AArsenicCheckpoint","text":"<p>This class is an example of how to save an object\u2019s data. We will likely be using this object for a long time, and it will likely be growing as our savable objects are added to the game.  The code is quite simple, I will let it speak for itself. It can be found in Actors-&gt;ArsenicCheckpoint. There is a blueprint version that gets added to the world as a checkpoint.</p>"},{"location":"Saving/#loading-data","title":"Loading Data","text":"<p>So far, the system only has two examples of loading data and that can be found in the <code>AArsenicPlayerState</code> and <code>AArsenicDoorBase</code>. Loading data is far simpler than you may expect so I won\u2019t  explain it here, but it\u2019s important to know where to find the examples: Player-&gt;AArsenicPlayerState &amp; Actors-&gt;Interaction-&gt;Doors-&gt;ArsenicDoorBase. The doors are an excellent example of tracking their state as <code>World Partition</code> loads and unloads them. I'm very proud of this feature!</p>"},{"location":"Saving/#creating-new-savable-objects","title":"Creating New Savable Objects","text":"<p>This is a very brief guide on the requirements to register your object with the save system:</p> <ol> <li>Within the header file of your savable object, create a struct that contains all necessary information. </li> <li>Add that struct as a variable to <code>UArsenicSaveGameObject</code> (you will need to add the header file too)</li> <li>Create a function in <code>IArsenicSaveGameInterface</code> that takes your struct as an input</li> <li>Implement that interface function in <code>UArsenicSaveGameSubsystem</code> (use the other functionss as a guide). Ensure this function sets your struct on the save game object</li> <li>Create a getter function in your savable object that returns your struct, but actually populates it with current data before doing so (this will be fetched by the checkpoint)</li> <li>Within <code>AArsenicCheckpoint</code>, add to <code>FetchSaveData</code> and <code>OnTriggerBoxBeginOverlap</code> to include your new functions. Feel free to create a member variable here for your struct if you need it</li> <li>On <code>BeginPlay</code> in your savable object, create logic that sets the state of your object back to the loaded data. You may need <code>SetActorTransform</code>, <code>SetActorRotation</code>, <code>SetHealth</code>, etc. This  is where the savable object actually uses the saved data that gets loaded. There is a bool on the <code>UArsenicSaveGameSubsystem</code> (<code>SaveObjectInitialized</code>) that gets set to true when the save game  object is loaded; use this if you want to ensure the save game object is actually initialized before accessing it.</li> </ol>"},{"location":"Saving/#helfup-tip-for-accessing-save-data","title":"Helfup Tip For Accessing Save Data","text":"<p>Because objects get initialized at different times, it\u2019s important that we access objects only after they\u2019ve been fully initialized. The <code>UArsenicSaveGameSubsystem</code> initializes the  <code>UArsenicSaveGameObject</code> that holds all the saved data, and as such has a delegate that gets broadcast when that happens, called <code>FOnSaveGameObjectLoadedDelegate</code>. This works in tandem with the  bool on the game instance called <code>SaveObjectInitialized</code>. For example:</p> <pre><code>void AArsenicPlayerState::SetPlayerStateFromSaveData()\n{\n    UArsenicSaveGameSubsystem* SaveSubsystem = UArsenicSaveGameSubsystem::Get(this);\n    UArsenicSaveGameObject* SaveGameObject = IArsenicSaveGameInterface::Execute_GetSaveGameData(SaveSubsystem);\n\n    if (SaveSubsystem-&gt;DoesSaveExist)\n    {\n        if (SaveSubsystem-&gt;SaveObjectInitialized)\n        {\n            FPlayerSave PlayerData = SaveGameObject-&gt;PlayerData;\n            ArsenicPlayerCharacter-&gt;SetActorTransform(PlayerData.PlayerTransform);\n            ArsenicPlayerCharacter-&gt;ArsenicPlayerController-&gt;SetControlRotation(PlayerData.PlayerControlRotation);\n\n            InitializeAttributes(SaveGameObject-&gt;PlayerAttributes);\n        }\n        else\n        {\n            if (BoundToDelegate) return;\n            SaveSubsystem-&gt;OnSaveGameObjectLoaded.AddDynamic(this, &amp;ThisClass::OnSaveGameObjectLoaded_Callback);\n            BoundToDelegate = true;\n        }\n    }\n    else\n    {\n        FCharacterAttributes NewPlayerAttributes;\n        InitializeAttributes(NewPlayerAttributes);\n    }\n}\n</code></pre> <p>If <code>SaveObjectInitialized</code> returns false, that means the game instance hasn\u2019t fully initialized our save game object and we cannot safely access the saved data. Instead (else), we simply  bind to the <code>OnSaveGameLoaded</code> delegate which re-calls <code>SetPlayerStateFromSaveData</code> when the game instance broadcasts that it has successfully initialized the save game object. Here\u2019s the callback for  reference:</p> <pre><code>void AArsenicPlayerState::OnSaveGameObjectLoaded_Callback()\n{\n    SetPlayerStateFromSaveData();\n}\n</code></pre>"}]}